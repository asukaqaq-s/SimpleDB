#ifndef LOG_RECORD_H
#define LOG_RECORD_H

#include <memory>
#include <string>
#include <vector>
#include <sstream>
#include <assert.h>

#include "config/type.h"
#include "file/block_id.h"
#include "file/page.h"
#include "log/log_manager.h"

namespace SimpleDB {

class Transaction;

enum class LogRecordType {
    INVALID = 0,
    // table heap related
    SETINT,
    SETSTRING,
    // txn related
    CHECKPOINT,
    BEGIN,
    COMMIT,
    ROLLBACK, // or called abort
};

/**
* @brief
* LogRecord is a interface that each record implements it
* All operations on table such as Update、Insert、Delete, will be viewed as   
* several SetInt and SetString.
*
* LOG HEADER (record size will be automatically add by logmanager)
* --------------------------------------------
* | LSN | txn_ID | prevLSN | Logtype | IsCLR |
* --------------------------------------------
* For CheckPoint、Commit、Abort、Start
* ----------
* | Header | 
* ----------
* For SetInt
* -----------------------------------------------------------------------------------
* | Header | FileName.size() | FileName | BlockNum | offset | Old value | New value |
* -----------------------------------------------------------------------------------
* For SetString
* -------------------------------------------------------------------------------------------------------------------------
* | Header | FileName.size() | FileName | BlockNum | offset | Old String Size | Old String | New String Size | New String |
* -------------------------------------------------------------------------------------------------------------------------
*/
class LogRecord {

public:

    LogRecord() = default;
    // virtual ~LogRecord() = default;

    void SetLsn(lsn_t lsn) {
        lsn_ = lsn;    
    }

    lsn_t GetLsn() {
        return lsn_;
    }

    txn_id_t GetTxnID() {
        return txn_id_;
    }
    
    LogRecordType GetRecordType() {
        return type_;
    }

    void SetPrevLSN(lsn_t lsn) {
        prev_lsn_ = lsn;
    }

    lsn_t GetPrevLSN() {
        return prev_lsn_;
    }
    
    void SetCLR() {
        is_clr_ = true;
    }
    
    bool IsCLR() {
        return is_clr_;
    }
    
    std::string GetHeaderToString() {
        std::string clr;
        if(is_clr_) 
            clr = "CLR";
        std::stringstream os;
        os << "Log ["
           << "lsn: " << lsn_ << " "
           << "txnID: " << txn_id_ << " "
           << "prevLSN: " << prev_lsn_ << " "
           << "LogRecordType: " << static_cast<int>(type_) <<" "
           << clr << "] ";

        return os.str();
    }
        
    virtual int RecordSize() = 0;

    virtual std::string ToString() = 0;

    /**
    * @brief 
    */
    virtual void Undo(Transaction *txn) = 0;
    
    /**
    * @brief 
    */
    virtual void Redo(Transaction *txn) = 0;

    /**
    * @brief turn a logrecord object into the byte-sequence
    * 
    * @return byte-sequence
    */
    virtual std::shared_ptr<std::vector<char>> Serializeto() = 0;

    /**
    * @brief turn byte-sequence into a logrecord
    * 
    * @param byte_array a byte array
    */
    static std::shared_ptr<LogRecord> DeserializeFrom(const std::vector<char> &byte_array);

    /**
    * @brief helper function which build a page with log header
    * 
    * @return a built page
    */
    static Page GetHeaderPage(txn_id_t txn_id, LogRecordType type, int is_clr, int record_size);

    /**
    * @brief helper function which get header information through page
    */
    void GetHeaderInfor(Page *p);

    
public: 
    // helper variable
    static constexpr uint32_t HEADER_SIZE = 
            sizeof(lsn_t) + sizeof(txn_id_t) + sizeof(lsn_t) + sizeof(LogRecordType) + sizeof(int);


protected: /* can be accessed by child class, can not be access by other class */
    
    // the corresponding lsn number which generated by logmanager
    lsn_t lsn_{INVALID_LSN};
    // the correspoding transaction_id
    txn_id_t txn_id_;
    // Used to construct a lsn_list
    lsn_t prev_lsn_{INVALID_LSN};
    // LogRecord Type
    LogRecordType type_;
    // is CLR_record ?
    int is_clr_{false};
};


class SetIntRecord : public LogRecord {

public:
    
    SetIntRecord() = default;
    
    SetIntRecord(Page *p);

    SetIntRecord(txn_id_t txn_id,  BlockId block, 
                    int offset, int old_value, int new_value);
    
    int RecordSize() override {
        return record_size_;
    }

    void Redo(Transaction *txn) override;
    
    void Undo(Transaction *txn) override;

    std::string ToString() override;
    
    std::shared_ptr<std::vector<char>> Serializeto() override;
    

    // for debugging purpose
    bool operator ==(const SetIntRecord &obj) const {
        return lsn_ == obj.lsn_ && txn_id_ == obj.txn_id_ && 
                prev_lsn_ == obj.prev_lsn_ && block_ == obj.block_ &&
                new_value_ == obj.new_value_ && old_value_ == obj.old_value_ &&
                record_size_ == obj.record_size_ && is_clr_ == obj.is_clr_;
    }
    
    bool operator !=(const SetIntRecord &obj) const {
        return !(obj == *this);
    }

private:
    
    BlockId block_;
    // the offset in block
    int offset_;
    
    int old_value_;
    
    int new_value_;
    
    int record_size_;
};


class SetStringRecord : public LogRecord {

public: 

    SetStringRecord() = default;
    
    SetStringRecord(Page *p);

    SetStringRecord(txn_id_t txn_id,  BlockId block, 
                    int offset, std::string old_string, std::string new_string);
    
    int RecordSize() override {
        return record_size_;
    }

    void Redo(Transaction *txn) override;
    
    void Undo(Transaction *txn) override;

    std::string ToString() override;

    std::shared_ptr<std::vector<char>> Serializeto() override;

    // for debugging purpose
    bool operator ==(const SetStringRecord &obj) const {
        return lsn_ == obj.lsn_ && txn_id_ == obj.txn_id_ && 
                prev_lsn_ == obj.prev_lsn_ && block_ == obj.block_ &&
                new_value_ == obj.new_value_ && old_value_ == obj.old_value_ &&
                record_size_ == obj.record_size_ && is_clr_ == obj.is_clr_;
    }
    
    bool operator !=(const SetStringRecord &obj) const {
        return !(obj == *this);
    }

private:
    
    BlockId block_;
    // the offset in block
    int offset_;
    
    std::string old_value_;
    
    std::string new_value_;

    int record_size_;
};


class CommitRecord : public LogRecord {

public:

    CommitRecord() = default;
    
    CommitRecord(Page *p) { 
        GetHeaderInfor(p); 
        assert(type_ == LogRecordType::COMMIT);
    }

    CommitRecord(txn_id_t txn_id) { 
        txn_id_ = txn_id;
        type_ = LogRecordType::COMMIT;
    }
    
    int RecordSize() override {
        return HEADER_SIZE;
    }

    void Redo(Transaction *txn) override { /* do nothing */ }
    
    void Undo(Transaction *txn) override { /* do nothing */}

    std::string ToString() override { return GetHeaderToString(); }

    std::shared_ptr<std::vector<char>> Serializeto() override;

    // for debugging purpose
    bool operator ==(const CommitRecord &obj) const {
        return lsn_ == obj.lsn_ && txn_id_ == obj.txn_id_ && 
                prev_lsn_ == obj.prev_lsn_ && is_clr_ == obj.is_clr_;
    }
    
    bool operator !=(const CommitRecord &obj) const {
        return !(obj == *this);
    }

private:
    // nothing
};


class CheckpointRecord : public LogRecord {

public:

    CheckpointRecord() : LogRecord() { type_ = LogRecordType::CHECKPOINT; }
    
    CheckpointRecord(Page *p) { 
        GetHeaderInfor(p);
        assert(type_ == LogRecordType::CHECKPOINT);
    }
    
    int RecordSize() override {
        return HEADER_SIZE;
    }

    void Redo(Transaction *txn) override { /* do nothing */ }
    
    void Undo(Transaction *txn) override { /* do nothing */}

    std::string ToString() override { return GetHeaderToString(); }

    std::shared_ptr<std::vector<char>> Serializeto() override;

    // for debugging purpose
    bool operator ==(const CheckpointRecord &obj) const {
        return lsn_ == obj.lsn_ && txn_id_ == obj.txn_id_ && 
                prev_lsn_ == obj.prev_lsn_ && is_clr_ == obj.is_clr_;
    }
    
    bool operator !=(const CheckpointRecord &obj) const {
        return !(obj == *this);
    }

private:
    // nothing
};


class BeginRecord : public LogRecord {

public:
    
    BeginRecord() = default;

    BeginRecord(txn_id_t txn_id) : LogRecord() { 
        txn_id_ = txn_id;
        type_ = LogRecordType::BEGIN; 
    }
    
    BeginRecord(Page *p) {
        GetHeaderInfor(p);
        assert(type_ == LogRecordType::BEGIN);
    }
    
    int RecordSize() override {
        return HEADER_SIZE;
    }

    void Redo(Transaction *txn) override { /* do nothing */ }
    
    void Undo(Transaction *txn) override { /* do nothing */}

    std::string ToString() override { return GetHeaderToString(); }

    std::shared_ptr<std::vector<char>> Serializeto() override;

    // for debugging purpose
    bool operator ==(const BeginRecord &obj) const {
        return lsn_ == obj.lsn_ && txn_id_ == obj.txn_id_ && 
                prev_lsn_ == obj.prev_lsn_ && is_clr_ == obj.is_clr_;
    }
    
    bool operator !=(const BeginRecord &obj) const {
        return !(obj == *this);
    }

private:
    // nothing
};


class RollbackRecord : public LogRecord {
    
public:
    
    RollbackRecord() = default;

    RollbackRecord(txn_id_t txn_id) : LogRecord() { 
        txn_id_ = txn_id;
        type_ = LogRecordType::ROLLBACK; 
    }
    
    RollbackRecord(Page *p) {
        GetHeaderInfor(p);
        assert(type_ == LogRecordType::ROLLBACK);
    }
    
    int RecordSize() override {
        return HEADER_SIZE;
    }

    void Redo(Transaction *txn) override { /* do nothing */ }
    
    void Undo(Transaction *txn) override { /* do nothing */}

    std::string ToString() override { return GetHeaderToString(); }

    std::shared_ptr<std::vector<char>> Serializeto() override;

    // for debugging purpose
    bool operator ==(const RollbackRecord &obj) const {
        return lsn_ == obj.lsn_ && txn_id_ == obj.txn_id_ && 
                prev_lsn_ == obj.prev_lsn_ && is_clr_ == obj.is_clr_;
    }
    
    bool operator !=(const RollbackRecord &obj) const {
        return !(obj == *this);
    }

private:
    // nothing

};

} // namespace SimpleDB

#endif